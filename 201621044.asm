NULL	WORD	0
A	RESW	1
B	RESW	1
C	RESW	1
D	RESW	1
E	RESW	1
F	RESW	1
G	RESW	1


.MAIN START DONT TOUCH
MAIN 		+JSUB	INITHEAP
		+JSUB	STKINIT
		+JSUB	READNUM

MAIN_I		WORD	0		
MAINLOOP	LDA	MAIN_I
		COMP	INPUTCNT
		JEQ	LOOPEND
		JGT	LOOPEND
		LDX	#0
		+JSUB	READLINE
		
		LDA	TREE
		COMP	#0
		JLT	NOTROOT
		JGT	NOTROOT
		LDA	PARENT
		+JSUB	MAKETREE
		
			
	
ROOTRIGHT	LDA	RIGHT
		COMP	#46
		JEQ	ROOTLEFT
		LDS	RIGHT
		LDT	TREE
		+JSUB	MAKERIGHTCHILD
		
ROOTLEFT	LDA	LEFT
		COMP	#46
		JEQ	PLUS_J
		LDS	LEFT
		LDT	TREE
		+JSUB	MAKELEFTCHILD

		J	PLUS_J				

NOTROOT		LDA	#FALSE
		STA	FIND
		
		LDA	TREE
		LDS	PARENT
		
		+JSUB	SEARCH
		
INNERLEFT	LDA	RIGHT
		COMP	#46
		JEQ	INNERRIGHT
		LDS	RIGHT
		LDT	TARGET
		+JSUB	MAKERIGHTCHILD

INNERRIGHT	LDA	LEFT
		COMP	#46
		JEQ	PLUS_J
		LDS	LEFT
		LDT	TARGET
		+JSUB	MAKELEFTCHILD

PLUS_J		LDA	MAIN_I
		ADD	#1
		STA	MAIN_I
		+J	MAINLOOP
		
LOOPEND		+J	PRINTRESULT


.MAIN END DONT TOUCH

.TESTTREE	+JSUB	INITHEAP
.		+JSUB	STKINIT
.		
.		LDA	#65
.		JSUB	MAKETREE
.		LDA	TREE
.		STA	A
.		LDS	#66
.		LDT	TREE
.		JSUB	MAKELEFTCHILD
.		STA	B
.		LDS	#67
.		LDT	TREE
.		JSUB	MAKERIGHTCHILD
.		STA	C
.		LDS	#68
.		LDT	B
.		JSUB	MAKELEFTCHILD
.		STA	D
.		LDS	#69
.		LDT	C
.		JSUB	MAKELEFTCHILD
.		STA	E
.		LDS	#70
.		LDT	C
.		JSUB	MAKERIGHTCHILD
.		STA	F
.		LDS	#71
.		LDT	F
.		JSUB	MAKERIGHTCHILD
.		STA	G
.		
.		LDA	#FALSE
.		STA	FIND
.
.		LDA	TREE
.		LDS	#71
.		
.		+JSUB	SEARCH
.		
.		J	END

.FLUSH	
FLUSH		TD	INPUT
		JEQ	FLUSH
		RD	INPUT
		LDA	#0
		RSUB

.PRINT	 INORDER		
PRINTRESULT	LDA	TREE	
		JSUB	INORDER
NEW_LINE1	TD	OUTDEV
		JEQ	NEW_LINE1
		LDA	#10
		WD	OUTDEV


.PRINT	PREORDER
		LDA	TREE
		JSUB	PREORDER
NEW_LINE2	TD	OUTDEV
		JEQ	NEW_LINE2
		LDA	#10
		WD	OUTDEV


.PRINT POSTOREDER
		LDA	TREE
		JSUB	POSTORDER
NEW_LINE3	TD	OUTDEV
		JEQ	NEW_LINE3
		LDA	#10
		WD	OUTDEV
		+J	END

.END PROGRAM	
END	+J	END

.MAIN DIRECTIVES
INPUTCNT	WORD	0
J		WORD	1

.READLINE ROUTINE
.BRINGS DATA INTO INPUTCNT
.ARGUMENTS NONE
.RETURNVALUES NONE
READNUM		RMO	L,A
		JSUB	PUSH
		JSUB	READBYTE
		RMO	A,T
		JSUB	POP
		RMO	A,L
		RMO	T,A
		COMP	#10
		JEQ	ENDREADNUM
		SUB	#48
		RMO	A,T
		LDA	INPUTCNT
		MUL	#10
		ADDR	T,A
		STA	INPUTCNT
		J	READNUM
ENDREADNUM	RSUB


.READBYTE ROUTINE
.ARGUMENTS NONE
.RETURNVALEUS ARE IN A REGISTER
.A IS CHAR READ FROM STDIN
READBYTE	TD	INPUT
		JEQ	READBYTE
		LDA	#0
		RD	INPUT
		RSUB


.READLINEDIRECTIVES
PARENT	RESW	1
RIGHT	RESW	1
LEFT	RESW	1
LENGTH	WORD	6
INPUT	BYTE	0
I	WORD	1
TEMPA	WORD	1

READLINE	TD	INPUT
		JEQ	READLINE
		LDA	#0
		RD	INPUT
		RMO	A, T
		RMO	X, A
		COMP	#0
		JEQ	STOREPARENT
		COMP	#2
		JEQ	STORELEFT
		COMP	#4
		JEQ	STORERIGHT
		TIX	LENGTH
		JLT	READLINE
		RSUB

STOREPARENT	STT	PARENT
		TIX	LENGTH
		JLT	READLINE

STORELEFT	STT	LEFT
		TIX	LENGTH
		JLT	READLINE

STORERIGHT	STT	RIGHT
		TIX	LENGTH
		JLT	READLINE

.INORDER TRAVERSAL
.ARGUMENTS ARE IN A
.A IS ADDRESS OF NODE
.HANDLE BASE CASE FIRST

TEMP_INORDER	RESW	1
OUTDEV		BYTE	1	

INORDER		STA	TEMP_INORDER
		LDA	TEMP_INORDER
		COMP	#0
		JGT	L1
		RSUB	

L1		TD	OUTDEV
		JEQ	L1
		LDA	@TEMP_INORDER
		WD	OUTDEV
		LDA	TEMP_INORDER

INLEFT		STA	TEMP_INORDER
		RMO	L,A
		JSUB	PUSH
		LDA	TEMP_INORDER
		JSUB	PUSH		

		LDA	TEMP_INORDER
		ADD	#LNODE
		STA	TEMP_INORDER
		LDA	@TEMP_INORDER

		JSUB	INORDER
		
		JSUB	POP
		STA	TEMP_INORDER
		JSUB	POP
		RMO	A,L
		LDA	TEMP_INORDER

INRIGHT		STA	TEMP_INORDER
		RMO	L,A
		JSUB	PUSH
		LDA	TEMP_INORDER
		JSUB	PUSH

		LDA	TEMP_INORDER
		ADD	#RNODE
		STA	TEMP_INORDER
		LDA	@TEMP_INORDER

		JSUB	INORDER

		JSUB	POP
		STA	TEMP_INORDER
		JSUB	POP
		RMO	A,L
		LDA	TEMP_INORDER
		
		RSUB


END_INORDER	JSUB	POP
		STA	TEMP_INORDER
		JSUB	POP
		RMO	A,L
		LDA	TEMP_INORDER

.PREORDER TRAVERSAL
.ARGUMENTS ARE IN A
.A IS ADDRESS OF NODE
.HANDLE BASE CASE FIRST

TEMP_PREORDER	RESW	1

	
PREORDER	STA	TEMP_PREORDER
		LDA	TEMP_PREORDER
		COMP	#0
		JGT	PRELEFT
		RSUB	

PRELEFT		STA	TEMP_PREORDER
		RMO	L,A
		JSUB	PUSH
		LDA	TEMP_PREORDER
		JSUB	PUSH		

		LDA	TEMP_PREORDER
		ADD	#LNODE
		STA	TEMP_PREORDER
		LDA	@TEMP_PREORDER

		JSUB	PREORDER
		
		JSUB	POP
		STA	TEMP_PREORDER
		JSUB	POP
		RMO	A,L
		LDA	TEMP_PREORDER

PREPRINT	TD	OUTDEV
		JEQ	PREPRINT
		LDA	@TEMP_PREORDER
		WD	OUTDEV
		LDA	TEMP_PREORDER

PRERIGHT	STA	TEMP_PREORDER
		RMO	L,A
		JSUB	PUSH
		LDA	TEMP_PREORDER
		JSUB	PUSH

		LDA	TEMP_PREORDER
		ADD	#RNODE
		STA	TEMP_PREORDER
		LDA	@TEMP_PREORDER

		JSUB	PREORDER

		JSUB	POP
		STA	TEMP_PREORDER
		JSUB	POP
		RMO	A,L
		LDA	TEMP_PREORDER
		
		RSUB

.POSTORDER TRAVERSAL
.ARGUMENTS ARE IN A
.A IS ADDRESS OF NODE
.HANDLE BASE CASE FIRST

TEMP_POSTORDER	RESW	1

	
POSTORDER	STA	TEMP_POSTORDER
		LDA	TEMP_POSTORDER
		COMP	#0
		JGT	POSTLEFT
		RSUB	

POSTLEFT	STA	TEMP_POSTORDER
		RMO	L,A
		JSUB	PUSH
		LDA	TEMP_POSTORDER
		JSUB	PUSH		

		LDA	TEMP_POSTORDER
		ADD	#LNODE
		STA	TEMP_POSTORDER
		LDA	@TEMP_POSTORDER

		JSUB	POSTORDER
		
		JSUB	POP
		STA	TEMP_POSTORDER
		JSUB	POP
		RMO	A,L
		LDA	TEMP_POSTORDER

POSTRIGHT	STA	TEMP_POSTORDER
		RMO	L,A
		JSUB	PUSH
		LDA	TEMP_POSTORDER
		JSUB	PUSH

		LDA	TEMP_POSTORDER
		ADD	#RNODE
		STA	TEMP_POSTORDER
		LDA	@TEMP_POSTORDER

		JSUB	POSTORDER

		JSUB	POP
		STA	TEMP_POSTORDER
		JSUB	POP
		RMO	A,L
		LDA	TEMP_POSTORDER

POSTPRINT	TD	OUTDEV
		JEQ	POSTPRINT
		LDA	@TEMP_POSTORDER
		WD	OUTDEV
		LDA	TEMP_POSTORDER
		
		RSUB



	
.HEAP INIT
INITHEAP	LDA	#HEAP
		STA	HEAPPTR
		RSUB

.HEAP DIRECTIVES
HEAP	RESW	1000
HEAPPTR	RESW	1

.MAKENODE PROCEDURE
.ARGUMENTS ARE IN REGISTER A
.A IS DATA BELONGS TO NEW NODE
.RETURN VALUE IS IN REGISTER A
.A IS START ADDRESS OF NEW NODE
.DIRECTIVES
MAKENODE_DATA	RESW	1

MAKENODE	RMO	A,S	.MOVE ARGUMENT TEMPORALILY IN S REGISTER
		LDT	HEAPPTR	
		RMO	T,A	
		ADD	#DATA	
		STA	MAKENODE_DATA
		RMO	S,A	.MOVE ARGUMENT INTO A REGISTER
		STA	@MAKENODE_DATA
		RMO	T,A
		ADD	#NODESIZE
		STA	HEAPPTR
		LDA	MAKENODE_DATA	.START ADDRESS OF NODE A IS 
		RSUB

.MAKELEFTCHILD PROCEDURE
.ARGUMENTS ARE IN REGSITER S AND T
.S IS DATA BELONGS TO NEW NODE
.T IS ADDRESS OF PARENT NODE
.RETURNVALUES ARE IN REGISTER A
.A IS START ADDRESS OF NEW NODE
.MAKELEFTCHILD DIRECTIVES
MAKELEFT_NEW_NODE_ADDR	RESW	1
MAKELEFT_DATA		RESW	1
MAKELEFT_PARENT_ADDR	RESW	1

MAKELEFTCHILD	RMO	S,A
		STA	MAKELEFT_DATA
		RMO	T,A
		STA	MAKELEFT_PARENT_ADDR
		RMO	L,A
		JSUB	PUSH
		LDA	MAKELEFT_DATA
		JSUB	MAKENODE
		STA	MAKELEFT_NEW_NODE_ADDR
		LDA	MAKELEFT_PARENT_ADDR
		ADD	#LNODE
		STA	MAKELEFT_PARENT_ADDR
		LDA	MAKELEFT_NEW_NODE_ADDR
		STA	@MAKELEFT_PARENT_ADDR
		JSUB	POP
		RMO	A,L
		LDA	MAKELEFT_NEW_NODE_ADDR
		RSUB
				
.MAKERIGHTCHILD PROCEDURE
.ARGUMENTS ARE IN REGSITER S AND T
.S IS DATA BELONGS TO NEW NODE
.T IS ADDRESS OF PARENT NODE
.RETURNVALUES	ARE IN REGISTER A
.A IS START ADDRESS OF NEW NODE
.MAKERIGHTCHILD DIRECTIVES
MAKERIGHT_NEW_NODE_ADDR	RESW	1
MAKERIGHT_DATA		RESW	1
MAKERIGHT_PARENT_ADDR	RESW	1

MAKERIGHTCHILD	RMO	S,A
		STA	MAKERIGHT_DATA
		RMO	T,A
		STA	MAKERIGHT_PARENT_ADDR
		RMO	L,A
		JSUB	PUSH
		LDA	MAKERIGHT_DATA
		JSUB	MAKENODE
		STA	MAKERIGHT_NEW_NODE_ADDR
		LDA	MAKERIGHT_PARENT_ADDR
		ADD	#RNODE
		STA	MAKERIGHT_PARENT_ADDR
		LDA	MAKERIGHT_NEW_NODE_ADDR
		STA	@MAKERIGHT_PARENT_ADDR
		JSUB	POP
		RMO	A,L
		LDA	MAKERIGHT_NEW_NODE_ADDR
		RSUB

.MAKETREE PROCEDURE
.ARGUMENTS ARE IN REGISTER A
.A IS DATA BELONGS TO NEW NODE
.DIRECTIVES
TREE	RESW	1

MAKETREE	RMO	A, S
		RMO	L, A
		JSUB	PUSH	.PUSH RETURN ADDRESS INTO STACK
		RMO	S, A
		JSUB	MAKENODE .CALL MAKENODE
		RMO	A, S
		JSUB	POP
		RMO	A, L
		RMO	S, A
		STA	TREE
		LDA	TREE
		RSUB

.SEARCH PROCEDURE
.ARGUMENTS ARE IN REGISTER S,T
.S DATA TO FIND
.A START NODE
.RETURNVAUES ARE IN REGISTER A
.A IS START ADDRESS OF NODE CONTAINS DATA
.DIRECTIVES 
TARGET			RESW	1
FIND			WORD	2
TRUE			EQU	1
FALSE			EQU	2
TEMP_TARGETVALUE	RESW	1

TEMP_SEARCH	RESW	1
	
SEARCH		STS	TEMP_TARGETVALUE
		STA	TEMP_SEARCH
		LDA	TEMP_SEARCH
		COMP	#0
		JGT	SEARCHPRINT
		JEQ	SEARCHEND
		LDA	FIND
		COMP	#TRUE
		JGT	SEARCHPRINT

SEARCHEND	RSUB

SEARCHPRINT	LDA	TEMP_TARGETVALUE
		COMP	@TEMP_SEARCH
		JLT	SEARCHLEFT
		JGT	SEARCHLEFT
		LDA	TEMP_SEARCH
		STA	TARGET
		LDA	#1
		STA	FIND
		RSUB

SEARCHLEFT	RMO	L,A
		JSUB	PUSH
		LDA	TEMP_SEARCH
		JSUB	PUSH	
		LDA	TEMP_TARGETVALUE
		JSUB	PUSH	
		
		LDS	TEMP_TARGETVALUE
		LDA	TEMP_SEARCH
		ADD	#LNODE
		STA	TEMP_SEARCH
		LDA	@TEMP_SEARCH
		LDT	TEMP_TARGETVALUE

		JSUB	SEARCH
		
		JSUB	POP
		STA	TEMP_TARGETVALUE
		JSUB	POP
		STA	TEMP_SEARCH
		JSUB	POP
		RMO	A,L
		LDA	TEMP_SEARCH
		LDT	TEMP_TARGETVALUE

SEARCHRIGHT	RMO	L,A
		JSUB	PUSH
		LDA	TEMP_SEARCH
		JSUB	PUSH	
		LDA	TEMP_TARGETVALUE
		JSUB	PUSH	
		
		LDS	TEMP_TARGETVALUE
		LDA	TEMP_SEARCH
		ADD	#RNODE
		STA	TEMP_SEARCH
		LDA	@TEMP_SEARCH
		LDT	TEMP_TARGETVALUE

		JSUB	SEARCH
		
		JSUB	POP
		STA	TEMP_TARGETVALUE
		JSUB	POP
		STA	TEMP_SEARCH
		JSUB	POP
		RMO	A,L
		LDA	TEMP_SEARCH
		LDT	TEMP_TARGETVALUE
			
SEARCHFIN	RSUB
	
.NODE DATA STRUCTURE
DATA		EQU	0
LNODE		EQU	3
RNODE		EQU	6
NODESIZE	EQU	9

.STACK INIT
STKINIT	LDA	#STACK
	STA	STACKPTR
	RSUB

.STACK PUSH
PUSH	STA	@STACKPTR
	LDA	STACKPTR
	ADD	#3
	STA	STACKPTR
	RSUB

.STACK POP
POP	LDA	STACKPTR
	SUB	#3
	STA	STACKPTR
	LDA	@STACKPTR
	RSUB

.STACK DIRECTIVES
STACKPTR	RESW	1
STACK		RESW	100000

